package AirSimJavaClient;

import java.util.HashMap;
import java.util.Map;

import org.nd4j.shade.jackson.databind.*;


import org.msgpack.rpc.*;

public class AirSimClient {

}

class AirSimImageType {    
    static int Scene = 0;
    static int DepthPlanner = 1;
    static int DepthPerspective = 2;
    static int DepthVis = 3;
    static int DisparityNormalized = 4;
    static int Segmentation = 5;
    static int SurfaceNormals = 6;
}

class Drivetraintype {
    static int MaxDegreeOfFreedom = 0;
    static int ForwardOnly = 1;    
}

class LandedState {
    static int Landed = 0;
    static int Flying = 1;
}

class MsgpackMixin {
   	ObjectMapper mapper = new ObjectMapper();
   	
    public Map to_msgpack(Object obj) {
    	return mapper.convertValue(obj, Map.class);
    }

    public Object from_msgpack(Object type, Map encoded) {
    	return mapper.convertValue(encoded, type.getClass());
    }
}

class Vector3r extends MsgpackMixin {
    float x_val = 0;
    float y_val = 0;
    float z_val = 0;

    public Vector3r(float x_val, float y_val, float z_val) {
        this.x_val = x_val;
        this.y_val = y_val;
        this.z_val = z_val;
    }
    
    public Vector3r() {
        this.x_val = 0;
        this.y_val = 0;
        this.z_val = 0;
    }
}
    
class Quaternionr extends MsgpackMixin {
    float w_val = 0;
    float x_val = 0;
    float y_val = 0;
    float z_val = 0;

    public Quaternionr (float x_val, float y_val, float z_val, float w_val) {
        this.x_val = x_val;
        this.y_val = y_val;
        this.z_val = z_val;
        this.w_val = w_val;
    }
    
    public Quaternionr () {
        this.x_val = 0;
        this.y_val = 0;
        this.z_val = 0;
        this.w_val = 1;
    }
}

class Pose extends MsgpackMixin {
    Vector3r position = new Vector3r();
    Quaternionr orientation = new Quaternionr();

    public Pose(Vector3r position_val, Quaternionr orientation_val) {
        this.position = position_val;
        this.orientation = orientation_val;
    }
}

class CollisionInfo extends MsgpackMixin {
    boolean has_collided = false;
    Vector3r normal = new Vector3r();
    Vector3r impact_point = new Vector3r();
    Vector3r position = new Vector3r();
    float penetration_depth = 0;
    float time_stamp = 0;
}

class GeoPoint extends MsgpackMixin {
    float latitude = 0;
    float longitude = 0;
    float altitude = 0;
}

class YawMode extends MsgpackMixin {
    boolean is_rate = true;
    float yaw_or_rate = 0;
    
    public YawMode(boolean is_rate, float yaw_or_rate) {
        this.is_rate = is_rate;
        this.yaw_or_rate = yaw_or_rate;
    }
    
    public YawMode() {
    	this.is_rate = false;
    	this.yaw_or_rate = 0;
    }
    
    public YawMode(float yaw_or_rate) {
    	this.is_rate = false;
    	this.yaw_or_rate = yaw_or_rate;
    }
}

class ImageRequest extends MsgpackMixin {
    int camera_id = 0;
    int image_type = AirSimImageType.Scene;
    boolean pixels_as_float = false;
    boolean compress = false;

    public ImageRequest(int camera_id, int image_type, boolean pixels_as_float, boolean compress) {
        this.camera_id = camera_id;
        this.image_type = image_type;
        this.pixels_as_float = pixels_as_float;
        this.compress = compress;
    }
    
    public ImageRequest(int camera_id, int image_type) {
        this.camera_id = camera_id;
        this.image_type = image_type;
        this.pixels_as_float = false;
        this.compress = true;
    }
    
    public ImageRequest(int camera_id, int image_type, boolean pixels_as_float) {
        this.camera_id = camera_id;
        this.image_type = image_type;
        this.pixels_as_float = pixels_as_float;
        this.compress = true;
    }


}

class ImageResponse extends MsgpackMixin {
    int image_data_uint8 = 0;
    float image_data_float = 0;
    Vector3r camera_position = new Vector3r();
    Quaternionr camera_orientation = new Quaternionr();
    int time_stamp = 0;
    String message = "";
    float pixels_as_float = 0;
    boolean compress = true;
    int width = 0;
    int height = 0;
    int image_type = AirSimImageType.Scene;
}

class AirSimClientBase {
	private Client client;
	
    public AirSimClientBase(String ip, int port) {
        this.client = new Client(Address(ip, port), 3600);
        
    }
    
    public ping() {
        return this.client.call("ping");
    }
    
    public void confirmConnection() {
        System.out.print("Waiting for connection: ");
        GeoPoint home = this.getHomeGeoPoint();
        while ((home.latitude == 0 && home.longitude == 0 && home.altitude == 0) ||
                Double.isNaN(home.latitude) || Double.isNaN(home.longitude) || Double.isNaN(home.altitude)) {
            Thread.sleep(1000);
            home = this.getHomeGeoPoint();
            System.out.print("X");
        }
        
        System.out.println("Connected");
    }
    
    public GeoPoint getHomeGeoPoint() {
        return GeoPoint.from_msgpack(this.client.call("getHomeGeoPoint"));
    }
    
    // Basic flight control
    public void enableApiControl(boolean is_enabled) {
        return this.client.call("enableApiControl", is_enabled);
    }
    
    public boolean isApiControlEnabled() {
        return this.client.call("isApiControlEnabled");
    }

//	//    camera control
//	//    simGetImage returns compressed png in array of bytes
//	//    image_type uses one of the AirSimImageType members
//    public simGetImage(self, camera_id, image_type) {
//        # because this method returns std{{vector<uint8>, msgpack decides to encode it as a string unfortunately.
//        result = this.client.call('simGetImage', camera_id, image_type)
//        if (result == "" or result == "\0") {
//            return None
//        return result
//
//    # camera control
//    # simGetImage returns compressed png in array of bytes
//    # image_type uses one of the AirSimImageType members
//    } def simGetImages(self, requests) {
//        responses_raw = this.client.call('simGetImages', requests)
//        return [ImageResponse.from_msgpack(response_raw) for response_raw in responses_raw]

    // static method
    public byte[]  stringToUint8Array(String bstr) {
        return bstr.getBytes();
    }
    
//    // static method
//    public stringToFloatArray(bstr) {
//        return np.fromstring(bstr, np.float32)
//    // static method
//    } def listTo2DFloatArray(flst, width, height) {
//        return np.reshape(np.asarray(flst, np.float32), (height, width))
//    // static method
//    } def getPfmArray(response) {
//        return AirSimClientBase.listTo2DFloatArray(response.image_data_float, response.width, response.height)

//    // static method
//    public Arrayget_public_fields(Object obj) {
//        return obj.get_fields();
//    }
//
//    // static method
//    } def to_dict(obj) {
//        return dict([attr, getattr(obj, attr)] for attr in AirSimClientBase.get_public_fields(obj))
//
//    // static method
//    } def to_str(obj) {
//        return str(AirSimClientBase.to_dict(obj))
//
//    // static method
//    } def write_file(filename, bstr) {
//        with open(filename, 'wb') as afile{
//            afile.write(bstr)
//
//    } def simSetPose(self, pose, ignore_collison) {
//        this.client.call('simSetPose', pose, ignore_collison)
//
//    } def simGetPose(self) {
//        return this.client.call('simGetPose')

    // helper method for converting getOrientation to roll/pitch/yaw
    // https{#en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles
    // static method
    } def toEulerianAngle(q) {
        z = q.z_val
        y = q.y_val
        x = q.x_val
        w = q.w_val
        ysqr = y * y

        # roll (x-axis rotation)
        t0 = +2.0 * (w*x + y*z)
        t1 = +1.0 - 2.0*(x*x + ysqr)
        roll = math.atan2(t0, t1)

        # pitch (y-axis rotation)
        t2 = +2.0 * (w*y - z*x)
        if (t2 > 1.0) {
            t2 = 1
        if (t2 < -1.0) {
            t2 = -1.0
        pitch = math.asin(t2)

        # yaw (z-axis rotation)
        t3 = +2.0 * (w*z + x*y)
        t4 = +1.0 - 2.0 * (ysqr + z*z)
        yaw = math.atan2(t3, t4)

        return (pitch, roll, yaw)

    // static method
    } def toQuaternion(pitch, roll, yaw) {
        t0 = math.cos(yaw * 0.5)
        t1 = math.sin(yaw * 0.5)
        t2 = math.cos(roll * 0.5)
        t3 = math.sin(roll * 0.5)
        t4 = math.cos(pitch * 0.5)
        t5 = math.sin(pitch * 0.5)

        q = Quaternionr()
        q.w_val = t0 * t2 * t4 + t1 * t3 * t5 #w
        q.x_val = t0 * t3 * t4 - t1 * t2 * t5 #x
        q.y_val = t0 * t2 * t5 + t1 * t3 * t4 #y
        q.z_val = t1 * t2 * t4 - t0 * t3 * t5 #z
        return q

    // static method
    } def wait_key(message = '') {
        ''' Wait for a key press on the console and return it. '''
        if message != ''{
            print (message)

        result = None
        if os.name == 'nt'{
            import msvcrt
            result = msvcrt.getch()
        else{
            import termios
            fd = sys.stdin.fileno()

            oldterm = termios.tcgetattr(fd)
            newattr = termios.tcgetattr(fd)
            newattr[3] = newattr[3] & ~termios.ICANON & ~termios.ECHO
            termios.tcsetattr(fd, termios.TCSANOW, newattr)

            try{
                result = sys.stdin.read(1)
            except IOError{
                pass
            finally{
                termios.tcsetattr(fd, termios.TCSAFLUSH, oldterm)

        return result

//    // static method
//    } def read_pfm(file) {
//        """ Read a pfm file """
//        file = open(file, 'rb')
//
//        color = None
//        width = None
//        height = None
//        scale = None
//        endian = None
//
//        header = file.readline().rstrip()
//        header = str(bytes.decode(header, encoding='utf-8'))
//        if header == 'PF'{
//            color = True
//        elif header == 'Pf'{
//            color = False
//        else{
//            raise Exception('Not a PFM file.')
//
//        temp_str = str(bytes.decode(file.readline(), encoding='utf-8'))
//        dim_match = re.match(r'^(\d+)\s(\d+)\s$', temp_str)
//        if dim_match{
//            width, height = map(int, dim_match.groups())
//        else{
//            raise Exception('Malformed PFM header.')
//
//        scale = float(file.readline().rstrip())
//        if scale < 0{ # little-endian
//            endian = '<'
//            scale = -scale
//        else{
//            endian = '>' # big-endian
//
//        data = np.fromfile(file, endian + 'f')
//        shape = (height, width, 3) if color else (height, width)
//
//        data = np.reshape(data, shape)
//        # DEY{ I don't know why this was there.
//        #data = np.flipud(data)
//        file.close()
//    
//        return data, scale
//
//    // static method
//    } def write_pfm(file, image, scale=1) {
//        """ Write a pfm file """
//        file = open(file, 'wb')
//
//        color = None
//
//        if image.dtype.name != 'float32'{
//            raise Exception('Image dtype must be float32.')
//
//        image = np.flipud(image)
//
//        if len(image.shape) == 3 and image.shape[2] == 3{ # color image
//            color = True
//        elif len(image.shape) == 2 or len(image.shape) == 3 and image.shape[2] == 1{ # greyscale
//            color = False
//        else{
//            raise Exception('Image must have H x W x 3, H x W x 1 or H x W dimensions.')
//
//        file.write('PF\n'.encode('utf-8')  if color else 'Pf\n'.encode('utf-8'))
//        temp_str = '%d %d\n' % (image.shape[1], image.shape[0])
//        file.write(temp_str.encode('utf-8'))
//
//        endian = image.dtype.byteorder
//
//        if endian == '<' or endian == '=' and sys.byteorder == 'little'{
//            scale = -scale
//
//        temp_str = '%f\n' % scale
//        file.write(temp_str.encode('utf-8'))
//
//        image.tofile(file)
//
//    // static method
//    } def write_png(filename, image) {
//        """ image must be numpy array H X W X channels
//        """
//        import zlib, struct
//
//        buf = image.flatten().tobytes()
//        width = image.shape[1]
//        height = image.shape[0]
//
//        # reverse the vertical line order and add null bytes at the start
//        width_byte_4 = width * 4
//        raw_data = b''.join(b'\x00' + buf[span{span + width_byte_4]
//                            for span in range((height - 1) * width_byte_4, -1, - width_byte_4))
//
//        } def png_pack(png_tag, data) {
//            chunk_head = png_tag + data
//            return (struct.pack("!I", len(data)) +
//                    chunk_head +
//                    struct.pack("!I", 0xFFFFFFFF & zlib.crc32(chunk_head)))
//
//        png_bytes = b''.join([
//            b'\x89PNG\r\n\x1a\n',
//            png_pack(b'IHDR', struct.pack("!2I5B", width, height, 8, 6, 0, 0, 0)),
//            png_pack(b'IDAT', zlib.compress(raw_data, 9)),
//            png_pack(b'IEND', b'')])
//
//        AirSimClientBase.write_file(filename, png_bytes)


# -----------------------------------  Multirotor APIs ---------------------------------------------
class MultirotorClient(AirSimClientBase, object) {
    } def __init__(self, ip, port) {
        if (ip == "") {
            ip = "127.0.0.1"
        super(MultirotorClient, self).__init__(ip, port)

    } def armDisarm(self, arm) {
        return this.client.call('armDisarm', arm)

    } def takeoff(self, max_wait_seconds = 15) {
        return this.client.call('takeoff', max_wait_seconds)
        
    } def land(self, max_wait_seconds = 60) {
        return this.client.call('land', max_wait_seconds)
        
    } def goHome(self) {
        return this.client.call('goHome')

    } def hover(self) {
        return this.client.call('hover')

        
    # query vehicle state
    } def getPosition(self) {
        return Vector3r.from_msgpack(this.client.call('getPosition'))
    } def getVelocity(self) {
        return Vector3r.from_msgpack(this.client.call('getVelocity'))
    } def getOrientation(self) {
        return Quaternionr.from_msgpack(this.client.call('getOrientation'))
    } def getLandedState(self) {
        return this.client.call('getLandedState')
    } def getGpsLocation(self) {
        return GeoPoint.from_msgpack(this.client.call('getGpsLocation'))
    } def getRollPitchYaw(self) {
        return this.toEulerianAngle(this.getOrientation())
    } def getCollisionInfo(self) {
        return CollisionInfo.from_msgpack(this.client.call('getCollisionInfo'))
    #} def getRCData(self) {
    #    return this.client.call('getRCData')
    } def timestampNow(self) {
        return this.client.call('timestampNow')
    } def isApiControlEnabled(self) {
        return this.client.call('isApiControlEnabled')
    } def isSimulationMode(self) {
        return this.client.call('isSimulationMode')
    } def getServerDebugInfo(self) {
        return this.client.call('getServerDebugInfo')


    # APIs for control
    } def moveByAngle(self, pitch, roll, z, yaw, duration) {
        return this.client.call('moveByAngle', pitch, roll, z, yaw, duration)

    } def moveByVelocity(self, vx, vy, vz, duration, drivetrain = DrivetrainType.MaxDegreeOfFreedom, yaw_mode = YawMode()) {
        return this.client.call('moveByVelocity', vx, vy, vz, duration, drivetrain, yaw_mode)

    } def moveByVelocityZ(self, vx, vy, z, duration, drivetrain = DrivetrainType.MaxDegreeOfFreedom, yaw_mode = YawMode()) {
        return this.client.call('moveByVelocityZ', vx, vy, z, duration, drivetrain, yaw_mode)

    } def moveOnPath(self, path, velocity, max_wait_seconds = 60, drivetrain = DrivetrainType.MaxDegreeOfFreedom, yaw_mode = YawMode(), lookahead = -1, adaptive_lookahead = 1) {
        return this.client.call('moveOnPath', path, velocity, max_wait_seconds, drivetrain, yaw_mode, lookahead, adaptive_lookahead)

    } def moveToZ(self, z, velocity, max_wait_seconds = 60, yaw_mode = YawMode(), lookahead = -1, adaptive_lookahead = 1) {
        return this.client.call('moveToZ', z, velocity, max_wait_seconds, yaw_mode, lookahead, adaptive_lookahead)

    } def moveToPosition(self, x, y, z, velocity, max_wait_seconds = 60, drivetrain = DrivetrainType.MaxDegreeOfFreedom, yaw_mode = YawMode(), lookahead = -1, adaptive_lookahead = 1) {
        return this.client.call('moveToPosition', x, y, z, velocity, max_wait_seconds, drivetrain, yaw_mode, lookahead, adaptive_lookahead)

    } def moveByManual(self, vx_max, vy_max, z_min, duration, drivetrain = DrivetrainType.MaxDegreeOfFreedom, yaw_mode = YawMode()) {
        return this.client.call('moveByManual', vx_max, vy_max, z_min, duration, drivetrain, yaw_mode)

    } def rotateToYaw(self, yaw, max_wait_seconds = 60, margin = 5) {
        return this.client.call('rotateToYaw', yaw, max_wait_seconds, margin)

    } def rotateByYawRate(self, yaw_rate, duration) {
        return this.client.call('rotateByYawRate', yaw_rate, duration)
